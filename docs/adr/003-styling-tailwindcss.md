# ADR-003: スタイリング: Tailwind CSS

## ステータス

Accepted

## コンテキスト

コンポーネントのスタイリング手法を決定する必要がある。
保守性、開発効率、パフォーマンスを考慮して選定する。

## 決定

Tailwind CSS を採用する。

## 選択肢

### 選択肢 1: Tailwind CSS

- メリット
  - ユーティリティファーストで高速な開発が可能
  - CSS ファイルを別途管理する必要がない
  - デザインシステムの一貫性を保ちやすい
  - 未使用スタイルの自動削除でバンドルサイズが小さい
  - v4 で大幅なパフォーマンス向上
- デメリット
  - クラス名が長くなりがち
  - 独自の記法を学習する必要がある
  - 複雑なスタイルは可読性が下がる場合がある

### 選択肢 2: CSS Modules

- メリット
  - 標準的な CSS 構文
  - スコープが自動的に分離される
  - 学習コストが低い
- デメリット
  - ファイル数が増える
  - 動的なスタイリングが難しい
  - デザインシステムの一貫性を保つのが難しい

### 選択肢 3: styled-components / Emotion

- メリット
  - CSS-in-JS で動的スタイリングが容易
  - コンポーネントとスタイルが同じファイルに
- デメリット
  - ランタイムコストがある
  - Server Components との相性が悪い
  - バンドルサイズが大きくなる

### 選択肢 4: Vanilla Extract

- メリット
  - ゼロランタイム CSS-in-JS
  - TypeScript との親和性が高い
- デメリット
  - 設定が複雑
  - エコシステムが小さい

## 理由

Tailwind CSS を採用する理由は以下の通り：

1. **開発効率**: HTML/JSX 内で直接スタイリングでき、ファイル切り替えが不要
2. **一貫性**: デザイントークンが組み込まれており、一貫したデザインを保ちやすい
3. **パフォーマンス**: ゼロランタイムで、未使用スタイルは自動削除
4. **Server Components 対応**: ランタイムがないため、Server Components と完全に互換
5. **エコシステム**: Headless UI、Radix UI などのライブラリとの相性が良い

## 結果

- Tailwind CSS v4 を使用
- PostCSS 経由で Next.js に統合
- 必要に応じて @apply でカスタムクラスを定義
- 複雑なコンポーネントは clsx や tailwind-merge を使用してクラスを管理
